# To be honest: We have to.

I think we can skip the ugly part of "Ready Player One" (get. the. book.) and get right to the "Awesomeness" of the coming times with "tech".

I really think we can skip the ugly part.

I must admit, I think I've given up trying to "know where all my files are".
IT simply got too much. At some times.

I feel I'm forced to say:
"I'm sorry, but files-and-folders, I'm moving on."

Therefore there ain't a way around letting go.
Saying goodbye to the good-old-hierarchical-files-and-folders paradidm.

> "The File System (classic)"

We've had our fun.
It was great and truly amazing!
Yet it's time to say goodbye. And let go of shelves and boxes and filenames and foldernames once and for all:

> Thank you my good old *f-and-f* friend:
> I'm setting up an Object Storage.
> I'm building Data Relationships.

For real this time.

And I really believe it's about time we all became aware of what a relief this step will be.

Put the meta-with-the-data. As consistent and meaningful as possible.
In annotated relationships. Cross-network-cross-OS-cross-anything boundaries:

**Q:Why?**
**A:Because it's "just the new filesystem everyone's using these days".**

Default libraries on any system that wants to support AHFX.
And that's how simple it will be:
Imagine being able to tag any data - any "thing" - virtually, literally anywhere - and exchange that data with any "thing" - even different software or other components - simply exchange "that data Object" around your current, past, present and future networks and "peers".

It's now all "just related data". With different tags and pathways around computing environments.

Literally "data lakes" with pools and pipes = networks - and pumps and transformers that make it "flow".


----------------------------------------------
End of "goodbye to classic filesystems" 


# IOFlow2

That's what the first Holodeck should be called.
Whatever it will be made of and like, its main design is to allow "flow of almost any input/output "data Objects"".

Similar to IOFlow's concept of "elements" for audio interface mappings, IOFlow2 applies a similar model to literally "anything data". I know pure-data exists, and I honor it greatly.

I'd love to see pd becoming a popular interface to "working with Object Storage Data Objects" :)

It may actually be a really clever tool to make work with the early prototypes -and even include it in standards-recommendations or so. As long as it's FOSS, so we can all share-alike(tm).

I'm pretty sure, and have it in my mind how, to apply generic programming-language "source code files" as templates onto Data Objects.
So they become "self-runnable". Literally "potentially active" Objects.

For example, a "mere JPG image" may in fact contain all the necessary relationships and tags to inform your downloading client to re-create (install, compile or build, and configure) your environment to match its "requirements" or "prerequisites".

This metaphor for handling data is immediately more suitable than the previous "default" for decades: known as "files in folders on drives - aka 'storage'".


# Imagine Active Objects

Simply double click on it.
Do you dare?
What could happen?

Literally anything.
Depends on how (you've?) configured IT.

Click on it.
It's just "A Demo" to show you what IT could be like.

A Demo.
Don't worry.
It's free.
And literally FREE Software (FOSS)-licensed.

Yes: License Text.
It's a thing. You should read it.
It's a contract you sign with "someone" at their terms.

Did you click it yet?

Great, isn't it?
Nothing happened.
Just kidding.

Now click the other one.
Yes, you must update first.
Got you there, didn't I?
You almost clicked on "update" - right?
Almost.

You didn't?
Did you?

What happened?
Better now?
Feeling better now?
Is your system better now?
Does "The App(tm)" make you (feel) better now?
More/less income?
Time?
Nerves?
Resources?
Space?


# Storage. Digital Data. Objects.

I keep repeating myself, yet I am not done yet, describing possible designs for this new kind of storage system.

It it already exists, with features that could be used as I've described here in my "Digital Mad Scientist" notes.
DMS-Syndrome. Look it up. It's a thing. At least was in my times.

Imagine transforming any digital data computing / processing scenario, assuming happily - and knowing "IT just works" - underlying filesystem that serves as "The Database" for anything.

As plain as a BIOS.
The Object-Filesystem.

I sound like I'm trying to sell a product, yet I'm selling to idea to engage in an endeavor to making this design a reality. Especially, because I'm convinced it's rather low-hanging fruit.

My only concern as of now is "performance".
Yet, considering that *all* proposed use-cases "The Holodeck By August" - aka "IOFlow2" could cover/replace/resolve: Already exist.

And must be "tackled and dealt with" by anyone who "uses com-pu-ters".
I truly believe so.

What is your opinion/situation?
user or ...?

# Anyways: Just save any data with any meta, as you please.

Create and annotate relationships, as you please.
As simple as right-click-whatever, anywhere. As you please.
Tag it. Relate it. Wikidata++ all over, as you please.

Directly on the filesystem.
Any "other application" is either part (plugin?) for your "Object Adventures"-Tool: An Object Browser/Explorer/Navigator. Whatever: Any user interface (graphical or text or other) may interpret and "render" your Data Objects as "IT makes sense".

You do that already all the time anyways:
Whenever an application reads a file format, it follows some specs, makes assumptions and does what it's told to do.

Whenever you're being "presented a search (query) input field", there is currently already "code and hardware" being setup in a way to "handle your request".

In whatever time is currently "accepted average".
Unless demanded "faster" or otherwise.

All this is already implemented in computing nowadays.
Yet, in ways that IMO consume more energy and computing - and data IO (flow) cycles than necessary.

Even if a "local global database-for-all" filesystem seams a huge thing: If we break that "Big Data" down into individual semi-local, so called "regional realms" of interconnected "Data Object" clouds, and distribute computing accordingly - we may spawn a new "Holodeck Network" sphere, that combines these "regional realms" - which each may have their own "Object Rules" and styles and conventions.

Imagine a big real-world-but-still-virtual-massive-only-multiplayer-pool-party: Data Pool Opening Party! 2024. A year to remember.

Whatever programming language, remember?
Active Objects: Source-code, or (pre-)compiled run-able code is allowed on Data Objects. Imagine Source-code literally becoming live, and interactively-usable by handling visually-representable "Data Objects".

Like drag-n-drop in your "File-Manager".
Then right-click-edit any Metadata, as you please.

Drag-and-drop it on top of another "Object": And you'll be asked what you'd like to do now. Similar to how we're already using graphical UIs at the moment.

Select any of your "Data" by "asking" your filesystem for something you "know" about your "fun quest with Data":

> $ select * from $tag=1981 and whatever; kthxbye.

And it'll present you with "your Data" in whatever form you've chosen to interact with "IT" now. CLI to GUI to VR to whatever.

Create Transformation Objects.

# Transformers

Transformation Objects - aka "Transformers" are Active Objects that form the "Main Digigestion System" (yes, that's not a typo). Data is Digigested from one "Node" (<- Active object ->) to another. If chosen to do so.

Simply imagine a pure-data (pd) like graphical user interface:
Any Object on your Filesystem can be depicted as a node (block) in a graph. With properties and input/output pads.

These are defined by "structure" or "interface code" provided in any desired/supported programming language.

Therefore "Programming Language Compilers" are automatically implemented/supported in all AHFX-compatible environments. In order to be able to "call" run-able Active Objects - aka "Call the Transformers()".

Imagine simply saving a Python Object Class source code (working, tested and stable) in a metadata-field of your JPG image "file".

That Object Class is loaded with other libraries (or references to), so enough "Code" to do anything it likes on your system. Environment.

According to "security settings".
Another story.

Ignore security to begin with.
It's included by design. Don't worry. More later.


# Double-Clicking on a "JPG" image. AHA-wise.

So, the Demo goes as follows:
You can search for anything on an Object Storage - Holodeck1 - aka "IOFlow2".

> $ select *.JPG;

Plain and effective. Straightforward.

If you double-click any of the presented JPGs, they'll "spawn" their default option to run a "player" that will show you its contents in a way they're inteded to.

If necessary, using Arch-Linux-ish architecture to compile-and-build any required computing environment tool-stack out of their mostly-plaintext form into a working proper "player" application.

As simple as that.

Now go and ask for metadata and relationships.
You may simply group any kind of objects - even results from previous queries - and refinements thereof. All the bells-and-whistles we already have plenty of implementations ready-to-use in FOSS-licensed cross-platform-web-certified toolchains.

Including Blender and FFmpeg and all the other developers' "gifts".

Add a URL (copy/paste) from any online source as simple "Object Tag", and you've already assigned a kind of "inter-compatible identifier" in a way that also would allow to "pull environment requirements or additional data" related to your Data Object(s) with links.

A Markdown file (*) refers to "pandoc" and offers (URI-fetched/optional) templates to create different output "variants". Options.
And if you like, you can easily add your own:

Right-Click-Edit.

(*) Or your operating system of course: It has a long list of "which Transformers() are required to convert X into Y" - and even translate IT completely to a new Object-Structure "data graph", if so desired.

I've once met a Professor from an Italian University (during PREFORMA) in 2014 - I think in Stockholm - and he told me about "The Future of Preservation":

> being that any Data Object is an AI-powered being that holds its own code. It's an active object, which is programmed "to survive" its contents - or "mission" as good as it can. And as smart and enduring as need to be.

Ressources: To be allocated."

But I think he didn't have any system to implement that with.
I didn't feel to comfortable about his energy, to be honest. Yet I must admit in hindsight, his idea sounded familiar.

I now know how to implement it.
By August :P


# Applied Source: "Use the Source (YJ)"

It should easily be possible to write a "decoder" that transforms existing Python programming code into its Object Class declarations - and each Class and Properties and Methods: Be simply copy-pasted - into Data Objects.

Think of it as:
Taking every "functional" text block of a source code project (like vim) - and save each one of those as an individual textfile.

Seems messy.
Feels noisy.
Feels unoptimized.
Feels the need to refactorize the "methods" and properties of each individual.

File.

But now it's Objects: That changes things.
You don't have to "see them in a folder".
No, they're not even "hidden".

They're "just not what you're looking for right now ... (YJ)"
*wavinghandwith2fingers+*

There's plenty of source code already being "executed" on your hardware as we speak.
By the sub-second.

Do you care?
I guess so.

Now that same source code also exists - with the overhead of Object Filesystem structure. Probably a few kilobytes at first - then Megabytes - and I wouldn't even exclude scenarios where an Object is heavily loaded with up to Gigabytes of "META" data.

Could literally be anything.
I thought about this many days and nights:
I believe it's better to stay with this basic assumption for our new Holodeck Filesystem:

> ðŸŒŸï¸ There's literally no more difference between meta and data. ðŸŒŸï¸
> It's over. Save anything anywhere.

Even binary "executable command code" if you like as "metadata".
Imagine a whole Blender, FFmpeg or Adobe suite "attached as 'tag' data" to a 3D or other media-object?

Why not?



# metaisdataismetaisdata.

So having working "library" source-code in your filesystem stored as related object-graphs, the "actual application" built to run code from the system, could very easily be viewed as both:

  1. its native form: source code text
  2. as pure-data interface, very possibly written for web-browser engines
     (currently: HTML5, CSS3, Java* - and other things, mostly FOSS and working)

I mean:
Programming code can be viewed, understood and edited "visually as a node-graph", or file-explorer since any structured view can be useful sometimes.

I think one thing though to limit is that only tags in the "META" part of an Object can contain to-be-interpreted relationship links to other "Objects".


# It all depends on.

As long as all functional requirements to make it awesome for everyone are freely available and funded by those who can afford to - public money, public code: Public code libraries.

That's what current libraries may offer as their most popular services:
Object Storage access.

And Workshops - and FOSS-and-Open-Hardware wherever possible.
Finally, a healthy computing environment, supported even by the industry.
Because it's just bloody awesome to be part of this.

It finally just works and makes sense.

Metaisdataismetaisdata.

Give me any computing challenge you're currently busy with - or annoyed by:
Okay, live-video-streaming-and-VR-porn may currently still be a performance or bandwidth or budget issue.

Imagine, any messenger is just "yet another app of your taste" to modify and transfer "communication Objects" - "CommObs". Tagged text.

It's hardly "sexy" anymore to come up with proprietary formats: Seeing binary (except media payload) data as "meta" - or "no meta" at all is considered "obscure Objects" - and kids are told to prefer "nicer" Objects:

If they are openly referenced or known in your community: Go for it.
You can literally make those Realms your own. Spawn as many as you like.

Go VR on that world as you see fit.
It may actually be plug-compatible with any massive-online-player game already existing. Minecraft if you will.

As long as the underlying specification, and open reference implementations are published and maintained by public libraries and others in the GLAM universe.

There have already been "Data Storage and Access" collaborations - with big projects, but I don't know about any "known" outcome of common Digital Heritage Data Repository.

To my knowledge, it's all in good faith - yet in big interoperability and access - especially licensing - challenges. Including Metadata wrangling.
Lots of.

And code-hacks.
Lots of.

Metaisdataismetaisdata

It helps.
Say, I'd like to take all my "braindump notes" I ever wrote - here on my NextCloud online-synchronized, awesome local-and-remote storage "solution". Awesome.
Thanks.

Going that way:
https://github.com/ThinkChaos/kodi-s3-source


# This is the uncomfortable part. Yet possibly entertaining.

It needs to be done anyways.
Any computing that wants to "survive" the IT-shift, may want to embrace thinking their use-cases and scenarios - and tools - in an Object Aware mode.

It's different.
Yet, it's quite LEGO.

Anyways, it has to be supported in programming code.
And being able to "see it as it it were files in folders" mount-options don't help.
It's over.

We are in the Object Era now :)
Enjoy!

Any application you like to use would need to be re-written (updated) to support eg S3 APIs or better. As long as they're "Public-Approved-by-Library" (PAL) seal/stamp.

This is also where budget and resources will come from:
Considering the amounts of EU-funded projects which produced "some code on some web-project site" - and was verwaist the minute the funding/project ended.

Orphaned.
Public money.
Our money.

And I know of many well-motivated and smart spirits who engaged in projects around "IT in cultural heritage" and cataloging and metadata and standards - and digitization and databanks, etc: Demotivated by the lack of "usefulness" and support experienced with these "projects".

Desillusioniert.







