I've set up and worked with quite a few large scale storages over the years, but when reading the (publicly) existing documentation, and watching other online materials about "big data" Object Storage architectures, I kind of doubt it has to be that complicated.

Maybe I am completely wrong on this one, since I am an Object Storage newbie.
However, what is already being promised by minio articles/docs, that it:

  * stores Objects - not files-in-folders
  * scales to exabyte or whatever cluster-size currently seems "future-safe-huge dude!"
  * works on a single node/disk
  * is designed to handle custom metadata
  * is designed to be used as a big data super-computing-whatever "key=value" store.
  * With Objects as little or many, as small or big as space allows: designed to work.

Okay, now what I do *not* understand is the following:

First of all:
Amazon AWS S3 "compatibility" introduces serious limitations and IMO backwards-thinking designs.

  * 10 tags
  * tags != metadata
  * custom metadata seems to be charset/length limited

So limited, that I cannot even copy/paste a plain exiftool plaintext (key=value) extraction of an MP3 file.
This seems odd.

I've therefore posted this:
https://github.com/minio/minio/discussions/19801


# Metadata usage and handling: Minio discusson #19801

I believe it's actually very very simple:

  * have a filesystem that can allocate blocks.
  * have all the state-of-the-art bells and whistles of a modern-day file-storage
    * replication
    * failover
    * cloud / cluster by design
    * versioning
    * encryption
    * compression
    * etc
  * and on top of that store "key=value".

Maybe we're already there, and I was looking for lego, but it's duplo - or the other way around.
Let's zoom out a bit:

If using literally each "storage Object" as "key" to storage "a value" - then that Object is actually "a key".
Therefore, we need to zoom out.

I'm not sure if it should be that way.
Or if it has to be that way.

Okay, so the Object itself can store small-to-large, even zero-size payload.

This makes it the perfect "Object for classic 'file' data" storage.
But why is the meta-part on that level so crippled?
And why separate the tags from metadata - even different api calls.

Why not just cache the tags as query-subset of "metadata"?
And have some policies and profiles and templates for all kinds of "common metadata scenarios"?

Why not simply break S3 and adjust the minio codebase to support:

  * something a bit like redis. but for any-size key=value data.
  * virtually unlimited key/value size.
  * bit-proof, therefore agnostic to data encoding.
  * no charset limits or issues: full unicode-if-text by default (includes emojis. seriously)
  * classic "file" data payload is stored as yet-another "key=value", named "payload=<DATA/>".
  * some query-language built-in to sparql (?) select any object on that storage.
  * access objects by id. (not by "path/filename" as key)
  * allow that id to be custom-generated by code/rules.
  * have even bucket/path/filename (yes, S3 still does that and calls it 'key') - as yet-another regular key=value entry.
  * allow multiple entries with identical keys.
    or enumerate them. or define a priority/preference profile syntax to sort/weigh them.
  * awareness of storing small- or quick-access data differently than large(r) or slow-access data. Transparently in the backend of the Object Storage filesystem architecture.
    AFAIU the docs, it somehow sounds like it's already doing something like that.

Maybe it's actually redis I'm looking for?
With the question though: if it works (in RAM), how could I copy that behavior to a proper large-scale long-and-short-term storage data system?

Or could redis actually be used for that already, by using its persistence/backup features?

> Anyways: 
> "plain and simple: key and value. nothing more."


I currently do not (yet) understand /if/ the current filesystem-and-database on top of Object Storage layers are (really) necessary. At least for providing a local-to-medium-size-scalable key-value-blob store filesystem database.
